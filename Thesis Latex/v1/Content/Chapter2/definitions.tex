\section{Defining Runtime Enforced Synchronous Neural Networks}
\subsection{\ac{VDTA}: Defining Safety Policies for \ac{CPS}}

We consider our industrial \ac{CPS} systems to have finite ordered sets of input values $\bin{I} = \{\bin{i_1}, \bin{i_2}, \ldots \bin{i_n}\}$ and output values $\bin{O} = \{\bin{o_1}, \bin{o_2}, \ldots \bin{o_n}\}$, where input and output values $\bin{i_n}$ and $\bin{o_n}$ are typed finite binary values.
However, for the purpose of the \ac{AV} case study used in this chapter, the input and output values $\bin{i_n}$ and $\bin{o_n}$ are fixed-point values, taking the form of 32-bit signed integer values.
The input alphabet is $\bin{\Sigma_I} = 32^{\bin{I}}$, i.e. the set made of all possible input value sets; and the output alphabet $\bin{\Sigma_O} = 32^{\bin{O}}$ is likewise the set made of all possible output value sets.
Finally, the input-output alphabet $\bin{\Sigma} = \bin{\Sigma_I} \times \bin{\Sigma_O}$. 
Each input and output event is denoted as a complete set of values, and an input-output event or reaction is of the form $(\bin{x_i}, \bin{y_i})$, where $\bin{x_i} \in \bin{\Sigma_I}$ and $\bin{y_i} \in \bin{\Sigma_O}$. 

\begin{example}
	\label{ex:io}
	Within our \ac{AV} braking example, using the \ac{VDTA} defined by the $\mathcal{V}_{ped}$ safety policy~\ref{fig:avpedrte}, let $\bin{I} = \{\bin{O_2}, \bin{O_5}, \bin{O_{2_v}}, \bin{O_{5_v}}, \bin{S}\}$ are 32-bit signed integers representing objects 2 and 5 in the system, their velocities and the speed of the vehicle respectively.
	Then, let the output $\bin{O} = \{\bin{D}\} = \{\bin{\langle A, B_S, B_H \rangle}\}$, where $\bin{D}$ is a vector of signed 32-bit integers, representing the \textit{decision} (action) taken by the vehicle this tick (\textit{Accelerate}, \textit{Soft Brake} and \textit{Hard Brake}).
	
	Then the input-output event $\bin{O_2}=65536$, $\bin{O_5}=0$, $\bin{O_{2_v}} = 655360$, $\bin{O_{5_v}} = 0$,  $\bin{S} = 4063232$, $\bin{D} = \langle 0, 0, 65536 \rangle$ is denoted as:\\$(\{65536, 0, 655360, 0, 4063232\}, \{\langle 0, 0, 65536 \rangle\})$ where each value is a fixed-point (32-bit signed integer) representation of a floating point value, i.e. Object 2 is a pedestrian, Object 5 is nothing, Object 2 is travelling at 10 km/h, Object 5 is not moving, and the vehicle's speed is 62 km/h, while the decided action for this tick is hard braking ($B_H$).
\end{example}

\begin{definition}
	\label{def:vdta}We define a \emph{\acf{VDTA}} as a tuple $\mathcal{V} = (L, l_0, l_v, \bin{\Sigma}, \bin{\Sigma_M}, V, F, \Delta)$ where
	\begin{itemize}
		\item $L$ is the set of \emph{locations},
		\item $l_0 \in L$ is the initial location,
		\item $l_v$ is a unique non-accepting \emph{trap} location,
		\item $\bin{\Sigma}$ is the valued input-output alphabet,
		\item $\bin{\Sigma_M} = 32^{\bin{M}}$ is the valued internal variable alphabet made from a set of internal variables $\bin{M}$,
		\item $V$ is a set of integer clocks,
		\item and $F \subseteq L$ is the set of accepting locations.
	\end{itemize}
	
	The transition relation $\Delta$ is $\Delta \subseteq L \times G(V,\bin{\Sigma},\bin{M}) \times R \times J \times L$ where ${G}(V,\bin{\Sigma},\bin{M})$ denotes the set of {\em guards}, i.e. constraints defined as conjunctions of simple constraints of the form $f(x) \bowtie g(y)$, with $x \in V \cup \bin{\Sigma} \cup \bin{M}$, $y \in V \cup \bin{\Sigma} \cup \bin{M} \cup \bbn$, $\bowtie~\in \{<,\leq,=,\geq,>\}$, and $f$ and $g$ any transformation functions. 
	
	$R\subseteq V$ is a subset of integer clocks that are reset to 0,
	and $J : V \times \bin{\Sigma} \times \bin{\Sigma}_{M} \times \bbn \rightarrow \bin{M}$ is an assignment function for the internal variables.
\end{definition}

\begin{example}
	The case study can be presented by four, different \acp{VDTA}; $\mathcal{V}_{ped}$, $\mathcal{V}_{car}$, $\mathcal{V}_{drive}$ and $\mathcal{V}_{cnn}$, as depicted in Figures~\ref{fig:avpedrte}, \ref{fig:avcarrte}, \ref{fig:avdriverte} and \ref{fig:avcnnrte} respectively. 
	For the purposes of these examples, the \ac{VDTA} for the pedestrian safety policy, $\mathcal{V}_{ped}$, is used.
	This \ac{VDTA} specifies that driving into a pedestrian in-front (if any) and not braking hard is a violation, and approaching a pedestrian from a distance (if any) and not starting to slow down (braking softly) is a violation.
	
	This is encoded as a \ac{VDTA} with accepting location $l_{drive}$ and non-accepting, non-violation location $l_{brake}$, with the initial state $l_{drive}$.
	We use the I/O specified in Example~\ref{ex:io}.
	
	In this \ac{VDTA} there are two violation transitions.
	$l_{drive} \rightarrow l_v$ occurs when the vehicle does anything else other than braking when there is a pedestrian in-front or not braking when there is no pedestrian ahead of the vehicle.
	$l_{brake} \rightarrow l_v$ can also occur when the vehicle has not braked enough within a certain period of time $T_{lim}$, or when the vehicle remains braking longer than is safe or necessary.
	This represents the vehicle taking further unsafe actions when already in an unsafe state.
\end{example}

Policy \ac{VDTA} are required to be \textit{deterministic}, i.e. for any given state, the conjunction of any guards of any other outgoing transitions may not be satisfiable; and \textit{complete}, i.e. for any given state at any given time and any given input-output event, at least one transition guard is satisfied.

\subsection{Semantics for \ac{VDTA}}

The semantics of a \ac{VDTA} are defined as a transition system where each state $q$ consists of the current location $l$, the current values of all the integer clocks $\chi$, and the current values of all internal variables $\bin{m}$.
The semantics of a \ac{VDTA} are defined as follows.

\begin{definition}[Semantics of \ac{VDTA}]
	\label{def:vdta:semantics}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	The {\em semantics} of a \ac{VDTA} is a transition system $\sem{\calV}=(Q, l_0, \bin{\Sigma}, Q_F, l_v, \to)$ where
	\begin{itemize}
		\item $Q= L \times \bbn^V \times \bin{\Sigma_M}$ is the set of {\em states},
		\item $l_0=(l_0, \chi_0, \bin{m}_0)$ is the {\em initial state}, where $\chi_0$ is the
		valuation that maps every integer clock variable in $V$ to zero, and $\bin{m}_0$ maps every internal value $\bin{\Sigma_M}$ to zero,
		\item $\bin{\Sigma}$ is the I/O alphabet,
		\item $Q_F= F \times \bbn^V \times \bin{\Sigma_M}$ is the set of {\em accepting states},
		\item and $l_v = l_v\times\bbn^V \times \bin{\Sigma_M}$ is the set of trap states.
	\end{itemize}
	The transition relation $\to \subseteq Q\times \bin{\Sigma} \times Q$ is a set of transitions of the form
	$(l,\chi,\bin{m})\xrightarrow{\bin{a}}(l',\chi',\bin{m}')$, with $\bin{a} \in \bin{\Sigma}$, $\chi'=(\chi+1)[r \leftarrow 0]$ and $\bin{m}' = j(\chi, \bin{a}, \bin{m})$, i.e. a transition between locations $l$ and $l'$ can occur whenever there exists $(l, g, r, j, l') \in \Delta$ and $\bin{a} \in \bin{\Sigma}$ and $\bin{m} \in \bin{\Sigma_M}$ such that $(\chi, \bin{a}, \bin{m}) \models g$, and when transitions occur, all clocks advance except for those which are reset to 0 by reset relation $r$, and all internal variables $\bin{m}$ are updated to new values by function $j$. 
\end{definition}

A {\em run} $\rho$ of $\calV$ is a sequence of moves in $\sem{\calV}$ denoted as $\rho = q \xrightarrow {\bin{a}_1} l_1\cdots l_{n-1}\xrightarrow {\bin{a}_n} l_{n}$, for some $n\in\bbn$. %, and is denoted as $q \xrightarrow {\bin{\sigma}} l_n$.
A run is \textit{accepted} by $\calV$ if it ends in an accepting state $l_n \in Q_F$, and a run is \textit{non-accepting} if it ends in a non-accepting state $l_n \in l_v$.


\begin{example}
	\label{ex:run}
	An example run of the VDTA presented in Figure~\ref{fig:avpedrte} is presented here.
	Assume that the time the vehicle has to be braking $T_{lim} = 2$ (2 clock ticks) and that one event occurs every second. 
	The starting state is $l_{drive}$, and the first I/O event is $(\{0, 0, 0, 0, 4063232\}, \{\langle 0, 0, 0 \rangle\})$, i.e. nothing is detected in-front of the vehicle and the vehicle does not accelerate or brake, meaning it is cruising at 62 km/h.
	Thus, the automaton remains in state $l_{drive}$.
	Next tick, $(\{0, 65536, 0, 655360, 4063232\}, \{\langle 0, 65536, 0 \rangle\})$ occurs, i.e. a pedestrian is detected quite far ahead of the vehicle, moving across the road at 10 km/h, and the vehicle is taking a soft braking action from 62 km/h.
	Since $\bin{O} = \{\langle 0, 65536, 0 \rangle\}$ which is a soft brake $B_S$ and Object 5, far ahead of the vehicle, is a pedestrian $O_5 = 65536 = O_{5_P}$ the system enters the unsafe state $l_{brake}$ and $t = 0$ is set.
	Then,  $(\{65536, 0, 0, 0, 2621440\}, \{\langle 0, 0, 0 \rangle\})$ is received, i.e. the pedestrian has stopped moving in the road and is now close to the vehicle, however the vehicle is not braking, but rather cruising at 40 km/h.
	Since no braking is detected, the violation transition $l_v$ is taken.
	As such, this run was \textit{non-accepting}.
\end{example}

\subsection{Defining Safety Automata for an \ac{AV} system}
In order for the \ac{AV} system to operate safely, it must follow a set of policies ($\mathcal{V}$), defined in English here:

$\mathcal{V}_{cnn}$: The output of the vision \ac{CNN} ensemble networks ($O$) must match the \ac{LiDAR} values ($L$) when the confidence of the ensemble networks is low. 
If the confidence is high, and there is a mismatch, the output should be classified as \textit{unknown} ($U$).
The system should treat this output as if it were a pedestrian, i.e. with utmost caution.

$\mathcal{V}_{drive}$: The vehicle may not exceed the safe speed limit. 
An \textit{acceleration} command $A$ should be suppressed when the vehicle's speed limit of 100km/h is reached.

$\mathcal{V}_{car}$: Ensure that the car does not drive into other vehicles. If an \textit{acceleration} command $A$ is asserted when the car in front (i.e. $O_{2_C}$ or $O_{5_C}$) is driving slower than the \ac{AV} ($O_{2_V}<S|O_{5_V}<S$), then this is suppressed and instead an appropriate brake speed $B_S$ (soft) or $B_H$ (hard) would be asserted instead.

$\mathcal{V}_{ped}$: Ensure that the car does not behave unsafely around pedestrians. If a pedestrian appears in-front of the vehicle $P=true$, then the car should select an appropriate braking action (either $B_S$ or $B_H$). If a pedestrian remains off to the side of the vehicle, then either the vehicle should cruise or a braking action is appropriate.

We can define these rules of the \ac{AV} system as a \textit{Safety Automata}~\cite{recps}, which are a kind of \acf{DTA}. 
Examples of this are presented in Figures \ref{fig:avpedrte} - \ref{fig:avcnnrte}, which represent the automata used in the four policies of the \ac{AV} system.
%Here, $A$ refers to the accelerate action, $B_S$ refers to a slow, or gentle, braking action, $B_H$ refers to a hard braking action.
$P$ is a flag that denotes the presence of a pedestrian in a position that will be dangerous at any point in the future, and $t$ is a timer that ensures that the \ac{AV} has braked for long enough and in time when a collision with a pedestrian has been detected, denoted by the time $T_{lim}$. 
$T_{lim}$ is a predefined length of time by which the system should have reacted to a pedestrian in a dangerous position.

Finally, a complete policy framework can be established by simply ANDing the component policies together, i.e. \\ $\mathcal{V}_{av} = \mathcal{V}_{cnn} \wedge \mathcal{V}_{drive} \wedge \mathcal{V}_{car} \wedge \mathcal{V}_{ped}$.

\begin{figure}[t]
	\centering
	\includegraphics[width=\linewidth]{avpedrte.tikz}
	\caption{Safety Automaton for Policy $\mathcal{V}_{ped}$\label{fig:avpedrte}}
\end{figure}
\begin{figure}[t]
	\centering
	\includegraphics[width=\linewidth]{avcarrte.tikz}
	\caption{Safety Automaton for Policy $\mathcal{V}_{car}$\label{fig:avcarrte}}
\end{figure}
\begin{figure}[t]
	\centering
	\includegraphics[width=\linewidth]{avdriverte.tikz}
	\caption{Safety Automaton for Policy $\mathcal{V}_{drive}$\label{fig:avdriverte}}
\end{figure}
\begin{figure}[t]
	\centering
	\includegraphics[width=\linewidth]{avcnnrte.tikz}
	\caption{Safety Automaton for Policy $\mathcal{V}_{cnn}$\label{fig:avcnnrte}}
\end{figure}


\subsection{Enforcing Non-accepting I/O Events}
Enforcers are designed to prevent a system from generating an input/output trace that is non-accepting, such as Example~\ref{ex:run}.
\cite{recps} proposed \ac{DTA} semantics with two possible methodologies for editing non-accepting I/O events.
These are \textit{random} and \textit{minimum} edits; a random edit chooses a random, accepting event from a list of accepting I/O events and minimum edit chooses the closest accepting event to the current non-accepting event.
However, neither of these edits are not always useful for problems in real scenarios.
Take Example~\ref{ex:run}, when the transition $l_{drive} \rightarrow l_v$ is taken, Object 2 can be edited such that $l_v$ is not entered, however this will not remove the danger that initially posed this transition.
However, if the action $\bin{O}$ was changed, e.g. the cruising action in the example that caused the non-accepting trace was changed to a hard braking action, then an accepting event would have occurred \textit{and} the pedestrian in the road would have been safe.


%The first policy, $\mathcal{V}_{cnn}$, compares the \ac{LiDAR} depiction and the classified image class from the corresponding ensemble outputs, if the \ac{LiDAR} and ensemble outputs are different, and the ensemble confidence value is low, the ensemble output is changed to match the output of the corresponding \ac{LiDAR} reading.
%If the ensemble confidence is high, both the \ac{LiDAR} reading and the corresponding ensemble output are changed to signal that the object detected is \textit{Unknown} and should be treated with extra caution, as if the object were a pedestrian.
%The second policy, $\mathcal{V}_{drive}$, ensures that the vehicle maintains reasonable driving practices on the road, e.g. not staying stationary in the middle of the road and not speeding.
%If the \ac{AV} controller outputs that the \ac{AV} should \textbf{accelerate} while the \ac{AV} is at the speed limit, the \textbf{accelerate} command would be changed to a  \textbf{cruise} command.
%Likewise, if the \ac{AV} controller decides that the \ac{AV} should remain stationary in an empty road, the \textbf{brake} (or \textbf{cruise}) command would be modified to an \textbf{accelerate} command.
%The third policy, $\mathcal{V}_{car}$, checks the environment for other vehicles and ensures that the \ac{AV} does not drive into other vehicles, or cause accidents with other vehicles in any way.
%If the \ac{AV} would \textbf{accelerate} into a vehicle in front, the \textbf{accelerate} would be changed to a \textbf{cruise}, if the \ac{AV} was driving much faster than the vehicle in front and the \ac{AV} is not braking, the current action would be modified to be a \textbf{brake} action.
%The fourth, and highest priority, policy ($\mathcal{V}_{ped}$) monitors the environment for pedestrians and ensures that the car does not exhibit unsafe behaviour with regards to the pedestrians. 
%If the \ac{AV} were to \textbf{accelerate}, or \textbf{cruise}, into a pedestrian that is in front of the vehicle, or approaching the road from the sides, the \textbf{accelerate}, or \textbf{cruise}, action would be changed to a \textbf{brake} action.
%If the \ac{AV} does not brake fast enough with a pedestrian in front of the \ac{AV}, or approaching from the sides, a \textbf{hard brake} action would be initiated instead of the \ac{ANN} proposed action.
%This policy ensures that the vehicle always drives slowly and cautiously around pedestrians.


\subsection{\ac{SANN}: Defining Artificial Neural Networks for \acp{CPS}}
\subsubsection{Defining the Layers of a \ac{SANN}}

\begin{definition}
	\label{def:layer}We define the \emph{\ac{SANN} Layers} as a tuple of layer types $\mathcal{L} = (I, D, O, C, A, M)$ where each layer type consists of $N$ nodes, each with an arrangement of 32-bit signed integers:
	\begin{itemize}
		\item $I$ is the input layer that consists only of $N$ 32-bit signed integers, where $N$ is the total number of inputs to the \ac{SANN}.
		\item $D$ is a dense layer, consisting of $N_{k-1} \times N_k$ 32-bit signed integer weights, where $N_k$ is the number of neurons in layer $k$ and $N_{k-1}$ is the number of neurons in the previous layer.
		\item $O$ is the output layer which is an instance of a dense layer $D$, consisting of $N$ neurons, where $N$ is the number of outputs of the \ac{SNN}.
		\item $C$ is a convolutional layer consisting of $N_k$ filters, each consisting of $M^2$ 32-bit signed integer weights, where $M$ is the filter size and $N_k$ is the number of filters in layer $k$.
		\item $A$ represents an average pooling layer, but has no 32-bit signed integer values, only a size with width $w$ and height $h$.
		\item $M$ represents an maximum pooling layer, but has no 32-bit signed integer values, only a size with width $w$ and height $h$.
	\end{itemize}
\end{definition}

\begin{definition}
	\label{def:cnn}
	A Synchronous \ac{CNN} is an extension of the previously defined \ac{SANN} from Definition~\ref{def:bb-mlp}.We define a \emph{Synchronous \ac{CNN}} as a tuple $\mathcal{C} = (I, O, L, A, \eta)$ where
	\begin{itemize}
		\item $I$ is a finite collection of 32-bit signed integer input variables with the domain \textbf{I}$ = 32^n$, where $n$ is the number of inputs.
		\item $O$ is a finite collection of 32-bit signed integer output variables with the domain \textbf{O}$ = 32^m$, where $m$ is the number of outputs.
		\item $L$ denotes a set of layers, defined by \ref{def:layer}.
		\item $A$ denotes the finite set of instantiated, connected layers in the \ac{CNN}, starting with the input layer $L_I$ and ending with the output layer $L_O$, with any assortment of layers from $L$ in-between, e.g. $A = (L_I, ..., L_O)$.
		\item $\eta$: \textbf{I} $\rightarrow$ \textbf{O} is the non-linear function, termed the network functions, that provides the behaviour of a given network, i.e. when provided a vector of $n$ inputs produces a vector of $m$ outputs. 
	\end{itemize}
\end{definition}

\begin{example}
	\label{ex:cnn}
	An example of one of the nine the object detection \acp{CNN} used in the the \ac{AV} case study is presented here.
	Any of the nine \acp{CNN} have $28 \times 28 \times 3 = 2352$, therefore \textbf{I}$ = \langle I_0, I_1 ..., I_2351 \rangle$.
	Likewise, each CNN has seven outputs resulting in \textbf{O}$ = \langle O_0, O_1 O_2 ..., O_7 \rangle$.
	Each \ac{CNN} has a set of layers $L$ defined by Definition \ref{def:layer}.
	The arrangement of layers $A$ consists of twelve layers in the following order: $A = \langle L_I, L_C, L_M, L_C, L_C, L_M, L_C, L_C, L_C, L_C, L_A, L_O \rangle$.
	The network function $\eta$ runs the \ac{CNN} such that an input image of size $28 \times 28 \times 3$ produces an output vector of size $7$.
\end{example}

\subsubsection{Running a Synchronous CNN}
A synchronous CNN can be run two different ways depending on the synchronous tick assignment of the CNN, see Section~\ref{sec:esterel-mapping} for more on tick analysis of \ac{SNN}. 
If the entire CNN is run each tick, the CNN is run using the function $\eta(I_k) = O_k$, where $I_k$ are the inputs for tick $k$ and $O_k$ are the outputs for tick $k$.
If only a single layer of the CNN is run each tick, the layer at $A_k$ is run as a function, where $k$ is the position of the layer in $A$ of the current tick.

\begin{example}
	\label{ex:runcnn}
	An example run of one of the nine the object detection \acp{CNN} used in Example \ref{ex:cnn} is presented here.
	An input image of a car, $28 \times 28$ pixels in colour is given to the \ac{CNN} network function $\eta$ as the input \textbf{I}.
	These pixels are flattened into a single layer of 2352 32-bit signed integers inputs and made into the input layer $L_I$.
	These inputs are then passed to the next layer of the \ac{CNN}, in this case a convolutional layer $L_C$.
	This convolutional layer has 32 filters and thus, after the 32 sets of matrix convolution, produces 32 sets of 2352 32-bit signed integer values.
	These $32 \times 2352$ values are then passed on to the next layer: a $2 \times 2$ maxpooling layer $L_M$.
	This layer takes each set of 2352 values and trims them down to $2353 / (2 \times 2) = 588$ values.
	These 32 sets of 588 values are then passed on to the next convolutional layer $L_C$ with 16 filters.
	And so on.
	Until the values reach the output layer, where they are condensed into 7 distinct output values, making up the output matrix \textbf{O} which classifies the image with the values $\langle 0.02, 0.91, 0.03, 0.04, 0.00, 0.00, 0.00 \rangle$.
	This means that the \ac{CNN} is 91 \% confident that the input image is a vehicle, and only 2 \% confident that it is a person.
	Therefore $\eta(2352_{car}) = \langle 0.02, 0.91, 0.03, 0.04, 0.00, 0.00, 0.00 \rangle$
\end{example}














